<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XDLCoreGen: XDLCoreGen</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XDLCoreGen
   </div>
   <div id="projectbrief">XDL hard macro creation framework in C++.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">XDLCoreGen </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>XDLCoreGen provides a framework for creating FPGA hard macros in XDL (Xilinx <a class="el" href="class_design.html">Design</a> Language) for Xilinx Virtex 6 and 7 devices. It also implements a multiplier described in the paper "An Efficient Softcore Multiplier Architecture for Xilinx FPGAs" by Martin Kumm, Shahid Abbas and Peter Zipf.</p>
<h2>Usage</h2>
<h3>Creating a hard macro</h3>
<p>You can create a hard macro by adding configured <code><a class="el" href="class_slicel.html">Slicel</a></code>/<code><a class="el" href="class_slicem.html">Slicem</a></code> objects to a <code><a class="el" href="class_module.html">Module</a></code>, connecting them and adding ports. For more complex hard macros it is recommended to create a class that is derived from <code><a class="el" href="class_module.html">Module</a></code> which also gives you the ability to override the <code>place()</code> method for a specialized placing algorithm.</p>
<p>The <code><a class="el" href="class_module.html">Module</a></code> class contains slices, nets, and ports and is added to a <code><a class="el" href="class_design.html">Design</a></code>. The <code><a class="el" href="class_slicel.html">Slicel</a></code> class contains all configurable attributes of a <a class="el" href="class_slicel.html">Slicel</a> and nets describe connections between slice inputs and outputs.</p>
<div class="fragment"><div class="line">Module m = Module(&quot;testmodule&quot;);</div><div class="line"></div><div class="line">Slicel s = Slicel(&quot;testslicel1&quot;);</div><div class="line">s.set_attribute(&quot;A6LUT&quot;, &quot;A1*A2+A3&quot;);</div><div class="line">s.set_attribute(&quot;AOUTMUX&quot;, &quot;O6&quot;);</div><div class="line">m.add_slice(s);</div><div class="line"></div><div class="line">s = Slicel(&quot;testslicel2&quot;);</div><div class="line">s.set_attribute(&quot;B5LUT&quot;, &quot;A5&quot;);</div><div class="line">s.set_attribute(&quot;BOUTMUX&quot;, &quot;O5&quot;);</div><div class="line">m.add_slice(s);</div></div><!-- fragment --><p> This creates two Slices with a basic configuration and adds them to the module. For a more information about attributes read the <em><a class="el" href="class_slicel.html">Slicel</a> Configuration</em> section below.</p>
<p>Connections can be added with the <code>add_interconnect(&lt;netname&gt;)</code> method.</p>
<div class="fragment"><div class="line">m.add_interconnect(&quot;net1&quot;)-&gt;set_outpin(&quot;testslicel1&quot;, &quot;AMUX&quot;)-&gt;add_inpin(&quot;testslicel2&quot;, &quot;B5&quot;);</div></div><!-- fragment --><p> This creates a new <code><a class="el" href="class_net.html">Net</a></code> or uses the existing one with the name "net1", sets an output pin, and adds an input pin. A net can have one outpin and multiple inpins. <code>add_inpin()</code> method calls can be chained together because it returns a pointer to the <code><a class="el" href="class_net.html">Net</a></code> object.</p>
<p>Ports can be added with the <code>add_port()</code> method. Every port pin has to be used in a net. If it hasn't been used in a net previously you have to create a net with only that pin. </p><div class="fragment"><div class="line">m.add_port(&quot;in(0)&quot;, &quot;testslicel1&quot;, &quot;A1&quot;);</div><div class="line">m.add_interconnect(&quot;inpin&lt;0&gt;&quot;)-&gt;add_inpin(&quot;testslicel1&quot;, &quot;A1&quot;);</div><div class="line"></div><div class="line">m.add_port(&quot;out(0)&quot;, s, &quot;BMUX&quot;);</div><div class="line">m.add_interconnect(&quot;outpin&lt;0&gt;&quot;)-&gt;set_outpin(s.get_name(), &quot;BMUX&quot;);</div></div><!-- fragment --><p>Since hard macros can't contain power nets they have to be replaced by a port. You can use the convenience methods <code>add_vcc_connection()</code> and <code>add_ground_connection()</code> which add the pins to ground or vcc and create a port. </p><div class="fragment"><div class="line">m.add_vcc_connection(&quot;testslicel1&quot;, &quot;A2&quot;);</div><div class="line">m.add_ground_connection(&quot;testslicel1&quot;, &quot;A3&quot;);</div></div><!-- fragment --><p>To create an XDL file the module has to be added to a <code><a class="el" href="class_design.html">Design</a></code>. The <code><a class="el" href="class_design.html">Design</a></code> object needs a <code><a class="el" href="class_device.html">Device</a></code> to place the slices onto. </p><div class="fragment"><div class="line">Device d = Device(&quot;./devices/xc6vlx75tff484-3.xdl&quot;);</div><div class="line">Design test_design = Design(d);</div><div class="line">test_design.add_module(m);</div><div class="line">test_design.place(0, 0);</div></div><!-- fragment --><p>Now you can output the XDL source to any stream.</p>
<div class="fragment"><div class="line">cout &lt;&lt; test_design;</div></div><!-- fragment --><p>For an example of a hard macro implemented as a class derived from <code><a class="el" href="class_module.html">Module</a></code> with a custom placing algorithm see examples/ExampleModule.cpp.</p>
<h4>Creating a carry chain</h4>
<p>To create a carry chain the <em>PRECYINIT</em> attribute of the first slice in the chain has to be set to <em>0, 1</em> or <em>AX</em>. This is the initial value. For every slice in the chain except the last <em>COUTUSED</em> has to be set to <code>0</code> (active). For the last slice it has to be set to <code>#OFF</code>. For the next slices the COUT pin of the previous slice has to be connected to the CIN pin.</p>
<div class="fragment"><div class="line">Module m = Module(&quot;testmodule&quot;);</div><div class="line"></div><div class="line">Slicel s = Slicel(&quot;testslicel1&quot;);</div><div class="line">s.set_attribute(&quot;PRECYINIT&quot;, &quot;0&quot;);</div><div class="line">m.set_attribute(&quot;COUTUSED&quot;, &quot;0&quot;);</div><div class="line">m.add_slice(s);</div><div class="line"></div><div class="line">s = Slicel(&quot;testslicel2&quot;);</div><div class="line">m.set_attribute(&quot;COUTUSED&quot;, &quot;#OFF&quot;);</div><div class="line">m.add_slice(s);</div><div class="line"></div><div class="line">m.add_interconnect(&quot;carry&lt;0-1&gt;&quot;)-&gt;set_outpin(&quot;testslicel1&quot;, &quot;COUT&quot;)-&gt;add_inpin(&quot;testslicel2&quot;, &quot;CIN&quot;);</div></div><!-- fragment --><p>If you are using the build-in placing algorithm the slices have to be added to the module in the correct order.</p>
<h2>Using a hard macro</h2>
<p>To use the hard macro in VHDL you need to convert the **.xdl* file to a **.nmc* file using the <em>xdl</em> tool with the <em>-xdl2ncd</em> parameter and a **.nmc* file as output.</p>
<div class="fragment"><div class="line">xdl -xdl2ncd 32x32_pipelined.xdl 32x32_pipelined.nmc</div></div><!-- fragment --><p>This file can then be instanced as a component in VHDL with the file name as the component name. You have to add a location constraint by adding</p>
<div class="fragment"><div class="line">attribute LOC : string;</div><div class="line">attribute LOC of &lt;instance&gt; : label is &quot;SLICE_X0Y0&quot;;</div></div><!-- fragment --><p> to the declaration block of the architecture where <code>&lt;instance&gt;</code> is the name of the hard macro component instance and <code>SLICE_X0Y0</code> contains the placing offsets of your hard macro (default is X0Y0). The macro also has <code>vcc</code> and <code>gnd</code> inputs which have to be connected to <code>1</code> and <code>0</code>;</p>
<p>Here is an example of a VHDL wrapper for the integrated multiplier macro. </p><div class="fragment"><div class="line">library IEEE;</div><div class="line">use IEEE.STD_LOGIC_1164.ALL;</div><div class="line"></div><div class="line">entity Mutliplier_32_pipelined is</div><div class="line">    generic(word_size   : integer := 32);</div><div class="line">    Port ( a : in  STD_LOGIC_VECTOR (word_size-1 downto 0);</div><div class="line">           b : in  STD_LOGIC_VECTOR (word_size-1 downto 0);</div><div class="line">           p : out  STD_LOGIC_VECTOR (word_size+word_size-1 downto 0);</div><div class="line">           clk : in  STD_LOGIC);</div><div class="line">end Mutliplier_32_pipelined;</div><div class="line"></div><div class="line">architecture Behavioral of Mutliplier_32_pipelined is</div><div class="line">component 32x32_pipelined is</div><div class="line">    Port ( a : in  STD_LOGIC_VECTOR (word_size-1 downto 0);</div><div class="line">            b : in  STD_LOGIC_VECTOR (word_size-1 downto 0);</div><div class="line">            p : out  STD_LOGIC_VECTOR (word_size+word_size-1 downto 0);</div><div class="line">            clk : in  STD_LOGIC;</div><div class="line">            gnd : in  STD_LOGIC;</div><div class="line">            vcc : in  STD_LOGIC);</div><div class="line">end component;</div><div class="line">   attribute LOC : string;</div><div class="line">   attribute LOC of M1 : label is &quot;SLICE_X0Y0&quot;;</div><div class="line">begin</div><div class="line">    M1: component 32x32_pipelined</div><div class="line">        port map(p=&gt;p,</div><div class="line">                  a=&gt;a,</div><div class="line">                  b=&gt;b,</div><div class="line">                  clk=&gt;clk,</div><div class="line">                  gnd=&gt;&#39;0&#39;,</div><div class="line">                  vcc=&gt;&#39;1&#39;);</div><div class="line">end Behavioral;</div></div><!-- fragment --><h3>Simulating the output</h3>
<p>Since hard macros can't be used in a simulation, a VHDL representation has to be created first. To get this you have to generate a **.ncd* file using the <em>xdl</em> tool with the <em>-xdl2ncd</em> parameter and an output file with the **.ncd* ending.</p>
<div class="fragment"><div class="line">xdl -xdl2ncd 32x32_pipelined.xdl 32x32_pipelined.ncd</div></div><!-- fragment --><p>This **.ncd* file can then be converted to VHDL with the <em>netgen</em> tool.</p>
<div class="fragment"><div class="line">netgen -ofmt vhdl -sim -w 32x32_pipelined.ncd 32x32_pipelined.vhd</div></div><!-- fragment --><p> This VHDL output can then be used like any other VHDL entity and has the same configuration as the XDL macro.</p>
<h2>Creating device description files</h2>
<p><a class="el" href="class_device.html">Device</a> description files can be created with the xdl tool using the <code>-report</code> switch.</p>
<div class="fragment"><div class="line">xdl -report xc6vlx75tff784</div></div><!-- fragment --><h2><a class="el" href="class_slicel.html">Slicel</a> Configuration</h2>
<h4>General <a class="el" href="class_slicel.html">Slicel</a> configuration</h4>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Explanation </th><th>Value </th><th>Default  </th></tr>
<tr>
<td>PRECYINIT </td><td>Carry chain initial value. </td><td>#OFF (not used) <br />
0 <br />
1 <br />
AX (AX input pin) </td><td>#OFF </td></tr>
<tr>
<td>SRUSEDMUX </td><td>SR input of the flip-flops used. </td><td>#OFF (not used) <br />
0 (used) </td><td>#OFF </td></tr>
<tr>
<td>SYNC_ATTR </td><td>Reset type. </td><td>#OFF (not used) <br />
SYNC <br />
ASYNC </td><td>#OFF </td></tr>
<tr>
<td>COUTUSED </td><td>Carry chain output used. </td><td>#OFF (not used) <br />
0 (used) </td><td>#OFF </td></tr>
<tr>
<td>CLKINV </td><td>Clock inverter. </td><td>#OFF (not used) <br />
0 (used) </td><td>#OFF </td></tr>
</table>
<h4><a class="el" href="class_slicel.html">Slicel</a> LUT/Register configuration</h4>
<p>These attributes are prefixed by <em>A, B, C</em> or <em>D</em> and configure one logic unit in a slice.</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Explanation </th><th>Value </th><th>Default  </th></tr>
<tr>
<td>5FFINIT </td><td>5FF register initial value. </td><td>#OFF (not used)<br />
INIT0<br />
INIT1 </td><td>#OFF </td></tr>
<tr>
<td>5FFMUX </td><td>5FF register input selection. </td><td>#OFF (not used)<br />
O5 <br />
(A-D)X </td><td>#OFF </td></tr>
<tr>
<td>5FFSR </td><td>5FF register initial SR value. </td><td>#OFF (not used)<br />
SRLOW <br />
SRHIGH </td><td>#OFF </td></tr>
<tr>
<td>5LUT </td><td>O5 function. </td><td>string (see below) </td><td></td></tr>
<tr>
<td>5LUTNAME </td><td>O5 LUT name. </td><td>string </td><td></td></tr>
<tr>
<td>6LUT </td><td>O6 function. </td><td>string (see below) </td><td></td></tr>
<tr>
<td>6LUTNAME </td><td>O6 LUT name. </td><td>string </td><td></td></tr>
<tr>
<td>CY0 </td><td>Select carry <em>propagate</em> (DI) input. </td><td>#OFF (not used)<br />
O5 <br />
(A-D)X </td><td>#OFF </td></tr>
<tr>
<td>FF </td><td>Latch/register </td><td>#OFF (not used)<br />
#FF <br />
#LATCH </td><td>#OFF </td></tr>
<tr>
<td>FFNAME </td><td>Latch/register name </td><td>string </td><td></td></tr>
<tr>
<td>FFINIT </td><td>Latch/register initial value. </td><td>#OFF (not used)<br />
INIT0 <br />
INIT1 </td><td>#OFF </td></tr>
<tr>
<td>FFMUX </td><td>Latch/register input selection. </td><td>#OFF (not used)<br />
F7 <br />
CY (carry) <br />
XOR (previous carry XOR O6)<br />
(A-D)X (X input pass through) <br />
O5 (5LUT output) <br />
O6 (6LUT output)</td><td>#OFF </td></tr>
<tr>
<td>FFSR </td><td>Latch/register initial SR value. </td><td>#OFF (not used)<br />
SRLOW <br />
SRHIGH </td><td>#OFF </td></tr>
<tr>
<td>OUTMUX </td><td>OUTMUX output selection </td><td>#OFF (not used)<br />
A5Q (5FF output) <br />
F7 <br />
CY (carry) <br />
XOR (previous carry XOR O6) <br />
O5 (5LUT output) <br />
O6 (6LUT output) </td><td>#OFF </td></tr>
<tr>
<td>USED </td><td>O6 pass through output used. </td><td>#OFF (not used)<br />
0 (active) </td><td>#OFF </td></tr>
</table>
<h5>LUT configuration</h5>
<p>LUT configurations use variables A1-A5 for 5LUTs or A1-A6 for 6LUTs and the boolean operators from the table below. All LUTs use A for variables regardless of their name.</p>
<table class="doxtable">
<tr>
<th>Operator </th><th>Symbol  </th></tr>
<tr>
<td>NOT </td><td>~ </td></tr>
<tr>
<td>AND </td><td>* </td></tr>
<tr>
<td>OR </td><td>+ </td></tr>
<tr>
<td>XOR </td><td>@ </td></tr>
</table>
<p>Examples: </p><div class="fragment"><div class="line">s1.set_attribute(&quot;B6LUT&quot;, &quot;(A5*A6)&quot;);</div><div class="line">s2.set_attribute(&quot;D6LUT&quot;, &quot;(A6+~A6)*(((~A2*(A3*(A4@A5)))+(A2*(A3+(A4@A5)))))&quot;);</div><div class="line">s3.set_attribute(&quot;C5LUT&quot;, &quot;(((~A2*(A3*(A4@A5)))+(A2*(A3+(A4@A5)))))&quot;);</div></div><!-- fragment --><h2>Generating a <a class="el" href="class_multiplier.html">Multiplier</a> hard macro</h2>
<p>To customize the multiplier you can use the following parameters:</p>
<div class="fragment"><div class="line"> XDLCoreGen [OPTION...]</div><div class="line"></div><div class="line"> -d, --device_file &lt;path&gt;  Device file path.</div><div class="line">     --multiplier          Generate a mutliplier macro.</div><div class="line"> -o, --output &lt;path&gt;       Output file path. If omitted the output will be</div><div class="line">                           printed.</div><div class="line"> -p, --pipelined           Generate pipelined macro. Default: not pipelined</div><div class="line"> -x, --x_offset N          X offset for the placer. Default: 0</div><div class="line"> -y, --y_offset N          Y offset for the placer. Default: 0</div><div class="line"> -h, --help                Print help</div><div class="line"></div><div class="line">multiplier options:</div><div class="line"> -a, --a_length N  A input length. Default: 8</div><div class="line"> -b, --b_length N  B input length. Default: 8</div></div><!-- fragment --><p>To display a list of possible parameters use <em>-h</em> or <em>&ndash;help</em>.</p>
<p>Example: </p><div class="fragment"><div class="line">xdlcoregen --multiplier --a_length 32 --b_length 32 --pipelined --device_file &quot;./device/xc6vlx75tff484-3.xdl&quot; --output 32x32_pipelined.xdl</div></div><!-- fragment --><p> This creates a pipelined mutliplier with 32x32 inputs using the device described in <em>xc6vlx75tff484-3.xdl</em> and writes it to <em>32x32_pipelined.xdl</em>.</p>
<h2>Limitations</h2>
<p>This framework currently only supports the creation of hard macros. This means a design must contain a single module with ports and no further nets or instances. Only Slicels are fully implemented currently since this framework is designed for combinational logic designs.</p>
<h2>Credits</h2>
<ul>
<li>Martin Kumm, Shahid Abbas and Peter Zipf: An Efficient Softcore <a class="el" href="class_multiplier.html">Multiplier</a> Architecture for Xilinx FPGAs In: 22nd IEEE Symposium on Computer Arithmetic (ARITH 22), 2015 (<a href="http://www.uni-kassel.de/eecs/fileadmin/datas/fb16/Fachgebiete/Digitaltechnik/preprints/2015_ARITH_kumm.pdf">preprint</a>, copyright IEEE, <a href="http://dx.doi.org/10.1109/ARITH.2015.17">http://dx.doi.org/10.1109/ARITH.2015.17</a>)</li>
<li>Ghosh, Subhrashankha, "XDL-Based Hard Macro Generator" (2011). All Theses and Dissertations. 2507. <a href="https://scholarsarchive.byu.edu/etd/2507">https://scholarsarchive.byu.edu/etd/2507</a></li>
<li>Option parser library <a href="https://github.com/jarro2783/cxxopts">cxxopts</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
